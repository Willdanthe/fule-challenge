-- Active: 1739211085766@@127.0.0.1@5432@digix@desafio
/*
------------------------------------------------------------------

 						        DESAFIO (24/02/25)
                                TEMA: DESAFIO
						       THIAGO OLSZEWSKI

------------------------------------------------------------------
*/
-- USING SCHEMA DESAFIO FROM DIGIX DATABASE IN POSTGRESQL

/*
    CREATING TRIGGERS FOR THE CHALLENGE
*/

-- DROP TABLE VENDAS, COMPRAS, CLIENTES, ESTOQUE, FORNECEDORES, PRODUTOS, COMPRAS_PRODUTOS, VENDAS_PRODUTOS;

-- TRIGGER FOR CHECK IF THE CLIENT NEEDS AN CPF OR CNPJ
CREATE OR REPLACE FUNCTION FN_CHECK_CLIENT_TYPE()
RETURNS TRIGGER AS $$
BEGIN
    IF LENGTH(NEW.CPF_CNPJ) = 14 THEN
        RAISE NOTICE 'CPF DETECTED: %', NEW.CPF_CNPJ;
        ELSIF LENGTH(NEW.CPF_CNPJ) = 18 THEN
            RAISE NOTICE 'CNPJ DETECTED: %', NEW.CPF_CNPJ;
    ELSE
        RAISE EXCEPTION 'THE VALUE OF CPF_CNPJ IS INVALID: LENGHT MUST BE 14 OR 18 CHARACTERS';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TR_CHECK_CPF_CNPJ
BEFORE INSERT OR UPDATE ON CLIENTES
FOR EACH ROW
EXECUTE PROCEDURE FN_CHECK_CLIENT_TYPE();

-- CHECK CNPJ OF THE SUPPLIER
CREATE OR REPLACE FUNCTION FN_CHECK_CNPJ()
RETURNS TRIGGER AS $$
BEGIN
    IF LENGTH(NEW.CPNJ) = 18 THEN
        RAISE NOTICE 'CNPJ DETECTED: %', NEW.CPNJ;
    ELSE
        RAISE EXCEPTION 'THE VALUE OF CNPJ IS INVALID: LENGHT MUST BE 18 CHARACTERS';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER TR_CHECK_CNPJ
BEFORE INSERT OR UPDATE ON FORNECEDORES
FOR EACH ROW
EXECUTE PROCEDURE FN_CHECK_CNPJ();

-- TRIGGER TO UPDATE THE TOTAL VALUE OF SALES
CREATE OR REPLACE FUNCTION FN_CALCULAR_VALOR_VENDA_TR()
RETURNS TRIGGER AS $$
DECLARE VALOR FLOAT;
BEGIN
    SELECT COALESCE(SUM(VP.QUANTIDADE * P.PRECO_UNITARIO), 0) INTO VALOR
    FROM VENDAS_PRODUTOS VP
    JOIN PRODUTOS P ON VP.FK_PRODUTO = P.ID
    WHERE VP.FK_VENDA = NEW.FK_VENDA;

    UPDATE VENDAS 
    SET VALOR_TOTAL = VALOR
    WHERE ID = NEW.FK_VENDA;
    RAISE NOTICE 'VALOR TOTAL ATUALIZADO: %', VALOR;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TR_VALOR_TOTAL_VENDA
AFTER INSERT OR UPDATE OR DELETE ON VENDAS_PRODUTOS
FOR EACH ROW
EXECUTE PROCEDURE FN_CALCULAR_VALOR_VENDA_TR();

-- 7.1 - TRIGGER PARA SUBTRAIR AUTOMATICAMENTE DO ESTOQUE AO VENDER
CREATE OR REPLACE FUNCTION FN_ATUALIZAR_ESTOQUE_VENDA()
RETURNS TRIGGER AS $$
DECLARE QTD INT;
BEGIN
    SELECT QUANTIDADE INTO QTD FROM ESTOQUE WHERE FK_PRODUTO = NEW.FK_PRODUTO;

    IF NEW.QUANTIDADE > QTD THEN
        RAISE EXCEPTION 'NÃO HÁ ESTOQUE SUFICIENTE DO PRODUTO %: SOLICITADO = %; ESTOQUE: %', NEW.FK_PRODUTO, NEW.QUANTIDADE, QTD;
    ELSE 
        UPDATE ESTOQUE SET QUANTIDADE = (QUANTIDADE - NEW.QUANTIDADE),
        DATA_ULTIMA_ATUALIZACAO = CURRENT_TIMESTAMP
        WHERE FK_PRODUTO = NEW.FK_PRODUTO;
        RAISE NOTICE 'SUCESSO NA VENDA % ', NEW.FK_VENDA;
        RETURN NEW;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TR_ATUALIZAR_ESTOQUE_VENDA
BEFORE INSERT OR UPDATE ON VENDAS_PRODUTOS
FOR EACH ROW
EXECUTE PROCEDURE FN_ATUALIZAR_ESTOQUE_VENDA();

-- 7.2 - TRIGGER PARA SOMAR AUTOMATICAMENTE AO ESTOQUE AO COMPRAR
CREATE OR REPLACE FUNCTION FN_ATUALIZAR_ESTOQUE_COMPRA()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE ESTOQUE SET QUANTIDADE = (QUANTIDADE + NEW.QUANTIDADE),
    DATA_ULTIMA_ATUALIZACAO = CURRENT_TIMESTAMP
    WHERE FK_PRODUTO = NEW.FK_PRODUTO;
    RAISE NOTICE 'SUCESSO NA COMPRA % ', NEW.FK_COMPRA;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TR_ATUALIZAR_ESTOQUE_COMPRA
BEFORE INSERT OR UPDATE ON COMPRAS_PRODUTOS
FOR EACH ROW
EXECUTE PROCEDURE FN_ATUALIZAR_ESTOQUE_COMPRA();

